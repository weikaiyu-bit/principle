
编译的指令重排

volatile 不保证原子性

两个线程操作的时候 操作一个变量 number++的时候底层class字节码会被分割成多个指令，其中一个指令是pull ，也就是number加一后往硬盘写回数据，
线程执行太快，第一个线程将1刷会硬盘，另外一个线程也刷回去，导致两个线程操作改变值应该为2的，却还是1，导致数据不是原子性，数据错乱

volatile 有序性（禁止重排）
1、多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测
        volatile可以修饰变量禁止指令重排
        volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：
        一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。
        由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优作。
        内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。
        线程安全性获得保证
        工作内存与主内存同步延迟现象导致的可见性问题
        可以使用synchronized或volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。
        对于指令重排导致的可见性问题和有序性问题
        可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。
        
        
        
 2、复习单线程下的单例模式多线程单例模式下的volatile的使用
  详见SingletonDemoTow

 3、回顾JMM模型
  JMM模型大概可以理解为
   一个共享（内存）的数据，当多个线程改变他时，不可以改变共享（内存）的数据，需要拷贝到自己单线程的内存做运算，
   再往共享（内存）写回去的模型叫JMM模型